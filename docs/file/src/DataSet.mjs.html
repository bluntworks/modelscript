<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/DataSet.mjs | ModelScript</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="//www.googletagmanager.com/gtag/js?id=UA-112697260-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-112697260-3');
  </script><meta name="description" content="Modelscript is a javascript module with simple and efficient tools for data mining and data analysis in JavaScript. When modelscript used with ML.js, pandas-js, and numjs, you&apos;re left with the equivalent R/Python tool set in JavaScript"><meta property="og:type" content="website"><meta property="og:url" content="https://repetere.github.io/modelscript"><meta property="og:site_name" content="ModelScript"><meta property="og:title" content="ModelScript"><meta property="og:image" content="https://repetere.ai/favicon.png"><meta property="og:description" content="Modelscript is a javascript module with simple and efficient tools for data mining and data analysis in JavaScript. When modelscript used with ML.js, pandas-js, and numjs, you&apos;re left with the equivalent R/Python tool set in JavaScript"><meta property="og:author" content="https://github.com/repetere"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="ModelScript"><meta property="twitter:description" content="Modelscript is a javascript module with simple and efficient tools for data mining and data analysis in JavaScript. When modelscript used with ML.js, pandas-js, and numjs, you&apos;re left with the equivalent R/Python tool set in JavaScript"><meta property="twitter:image" content="https://repetere.ai/favicon.png"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/repetere/modelscript"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ColumnVectorizer.mjs~ColumnVectorizer.html">ColumnVectorizer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DataSet.mjs~DataSet.html">DataSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ReinforcedLearning.mjs~ReinforcedLearningBase.html">ReinforcedLearningBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ReinforcedLearning.mjs~ThompsonSampling.html">ThompsonSampling</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/ReinforcedLearning.mjs~UpperConfidenceBound.html">UpperConfidenceBound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-assocationRuleLearning">assocationRuleLearning</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getTransactions">getTransactions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadCSV">loadCSV</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadCSVURI">loadCSVURI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-loadTSV">loadTSV</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-calc">calc</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cross_validation">cross_validation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PD">PD</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-calc">calc</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-cross_validation">cross_validation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-csv">csv</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-loadCSV">loadCSV</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-loadCSVURI">loadCSVURI</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ml">ml</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-model_selection">model_selection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-nlp">nlp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-preprocessing">preprocessing</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-util">util</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ml">ml</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-nlp">nlp</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PD">PD</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-util">util</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/DataSet.mjs</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { ml, } from &apos;./ml&apos;;
import { util as utils, } from &apos;./util&apos;;

const transformConfigMap = {
  scale: &apos;scaleOptions&apos;,
  descale: &apos;descaleOptions&apos;,
  label: &apos;labelOptions&apos;,
  labelEncoder: &apos;labelOptions&apos;,
  labeldecode: &apos;labelOptions&apos;,
  labelDecode: &apos;labelOptions&apos;,
  labelDecoder: &apos;labelOptions&apos;,
  onehot: &apos;oneHotOptions&apos;,
  oneHot: &apos;oneHotOptions&apos;,
  oneHotEncode: &apos;oneHotOptions&apos;,
  oneHotEncoder: &apos;oneHotOptions&apos;,
  reducer: &apos;reducerOptions&apos;,
  reduce: &apos;reducerOptions&apos;,
  merge: &apos;mergeData&apos;,
};

/**
 * class for manipulating an array of objects, typically from CSV data
 * @class DataSet
 * @memberOf preprocessing
 */
export class DataSet {
  /**
   * Allows for fit transform short hand notation
   * @example
DataSet.getTransforms({
  Age: [&apos;scale&apos;,],
  Rating: [&apos;label&apos;,],  }); //=&gt; [
//   {
//    name: &apos;Age&apos;, options: { strategy: &apos;scale&apos;, }, },
//   },
//   { 
//    name: &apos;Rating&apos;, options: { strategy: &apos;label&apos;, }, 
//   },
// ];
   * @param {Object} transforms 
   * @returns {Array&lt;Object&gt;} returns fit columns, columns property
   */
  static getTransforms(transforms = {}) {
    return Object.keys(transforms).reduce((result, columnName) =&gt; {
      const transformObject = {
        name: columnName,
        options: {
          strategy: (Array.isArray(transforms[ columnName ]))
            ? transforms[ columnName ][0]
            : transforms[ columnName ],
        },
      };
      if (Array.isArray(transforms[ columnName ]) &amp;&amp; transforms[ columnName ].length &gt; 1) {
        transformObject.options[ transformConfigMap[transforms[ columnName ][ 0 ]] ] = transforms[ columnName ][ 1 ];
      }
      result.push(transformObject);
      return result;
    }, []);
  }
  /**
   * returns an array of objects by applying labels to matrix of columns
   * @example
const data = [{ Age: &apos;44&apos;, Salary: &apos;44&apos; },
{ Age: &apos;27&apos;, Salary: &apos;27&apos; }]
const AgeDataSet = new MS.DataSet(data);
const dependentVariables = [ [ &apos;Age&apos;, ], [ &apos;Salary&apos;, ], ];
const AgeSalMatrix = AgeDataSet.columnMatrix(dependentVariables); // =&gt;
//  [ [ &apos;44&apos;, &apos;72000&apos; ],
//  [ &apos;27&apos;, &apos;48000&apos; ] ];
MS.DataSet.reverseColumnMatrix({vectors:AgeSalMatrix,labels:dependentVariables}); // =&gt; [{ Age: &apos;44&apos;, Salary: &apos;44&apos; },
{ Age: &apos;27&apos;, Salary: &apos;27&apos; }]
   * 
   * @param {*} options 
   * @param {Array[]} options.vectors - array of vectors
   * @param {String[]} options.labels - array of labels
   * @returns {Object[]} an array of objects with properties derived from options.labels
   */
  static reverseColumnMatrix(options = {}) {
    const { vectors, labels, } = options;
    const features = (Array.isArray(labels) &amp;&amp; Array.isArray(labels[ 0 ]))
      ? labels
      : labels.map(label =&gt; [label, ]);
    return vectors.reduce((result, val) =&gt; { 
      result.push(val.reduce((prop, value, index) =&gt; { 
        prop[ features[ index ][ 0 ] ] = val[index];
        return prop;
      }, {}));
      return result;
    }, []);
  }
  static reverseColumnVector(options = {}) {
    const { vector, labels, } = options;
    const features = (Array.isArray(labels) &amp;&amp; Array.isArray(labels[ 0 ]))
      ? labels
      : labels.map(label =&gt; [label, ]);
    return vector.reduce((result, val) =&gt; {
      result.push(
        { [ features[ 0 ][ 0 ] ]: val, }
      );
      return result;
    }, []);
  }
  /**
   * Returns an object into an one hot encoded object
   * @example
const labels = [&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;,];
const prefix = &apos;fruit_&apos;;
const name = &apos;fruit&apos;;
const options = { labels, prefix, name, };
const data = {
  fruit: &apos;apple&apos;,
};
EncodedCSVDataSet.encodeObject(data, options); // =&gt; { fruit_apple: 1, fruit_orange: 0, fruit_banana: 0, }
   * @param {Object} data - object to encode 
   * @param {{labels:Array&lt;String&gt;,prefix:String,name:String}} options - encoded object options
   * @returns {Object} one hot encoded object
   */
  static encodeObject(data, options) {
    const { labels, prefix, name,  } = options;
    const encodedData = labels.reduce((encodedObj, label) =&gt; { 
      const oneHotLabelArrayName = `${prefix}${label}`;
      encodedObj[oneHotLabelArrayName] = (data[name].toString() === label.toString()) ? 1 : 0;
      return encodedObj;
    }, {});
    return encodedData;
  }
  /**
 * returns a new object of one hot encoded values
 * @example
 * // [ &apos;Brazil&apos;,&apos;Mexico&apos;,&apos;Ghana&apos;,&apos;Mexico&apos;,&apos;Ghana&apos;,&apos;Brazil&apos;,&apos;Mexico&apos;,&apos;Brazil&apos;,&apos;Ghana&apos;, &apos;Brazil&apos; ]
const originalCountry = dataset.columnArray(&apos;Country&apos;); 

// { originalCountry:
//    { Country_Brazil: [ 1, 0, 0, 0, 0, 1, 0, 1, 0, 1 ],
//      Country_Mexico: [ 0, 1, 0, 1, 0, 0, 1, 0, 0, 0 ],
//      Country_Ghana: [ 0, 0, 1, 0, 1, 0, 0, 0, 1, 0 ] },
//     }
const oneHotCountryColumn = dataset.oneHotEncoder(&apos;Country&apos;); 
  * @param {string} name - csv column header, or JSON object property name 
  * @param options 
  * @see {@link http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html}
  * @return {Object}
  */
  static oneHotEncoder(name, options) {
    const config = Object.assign({
    }, options);
    const labelData = config.data || this.columnArray(name, config.columnArrayOptions);
    const labels = Array.from(new Set(labelData).values());
    const prefix = config.prefix||`${name}_`;
    const encodedData = labelData.reduce(
      (result, val, index, arr) =&gt; {
        labels.forEach(encodedLabel =&gt; {
          const oneHotLabelArrayName = `${prefix}${encodedLabel}`;
          const oneHotVal = (val === encodedLabel) ? 1 : 0;
          if (Array.isArray(result[oneHotLabelArrayName])) {
            result[oneHotLabelArrayName].push(oneHotVal);
          } else {
            result[oneHotLabelArrayName] = [oneHotVal,];
          }
        });
        return result;
      }, {});
    this.encoders.set(name, {
      name,
      labels,
      prefix,
    });
    return encodedData;
  }
  /**
   * Return one hot encoded data
   * @example
const csvData = [{
    &apos;Country&apos;: &apos;Brazil&apos;,
    &apos;Age&apos;: &apos;44&apos;,
    &apos;Salary&apos;: &apos;72000&apos;,
    &apos;Purchased&apos;: &apos;N&apos;,
  },
  {
    &apos;Country&apos;: &apos;Mexico&apos;,
    &apos;Age&apos;: &apos;27&apos;,
    &apos;Salary&apos;: &apos;48000&apos;,
    &apos;Purchased&apos;: &apos;Yes&apos;,
  },
  ...
];
const EncodedCSVDataSet = new ms.preprocessing.DataSet(csvData);
EncodedCSVDataSet.fitColumns({
  columns: [
    {
      name: &apos;Country&apos;,
      options: { strategy: &apos;onehot&apos;, },
    },
  ],
});

EncodedCSVDataSet.oneHotDecoder(&apos;Country);// =&gt;
// [ { Country: &apos;Brazil&apos; },
//  { Country: &apos;Mexico&apos; },
//  { Country: &apos;Ghana&apos; },
//  { Country: &apos;Mexico&apos; },
//   ...]
   * @param {string} name - column name 
   * @param options 
   * @returns {Array&lt;Object&gt;} returns an array of objects from an one hot encoded column
   */
  static oneHotDecoder(name, options) {
    const config = Object.assign({
      // handle_unknown: &apos;error&apos;
    }, options);
    const encoderMap = config.encoders || this.encoders;
    const prefix = config.prefix || encoderMap.get(name).prefix;
    const labels = config.labels || encoderMap.get(name).labels;
    const encodedData = config.data || this.oneHotColumnArray(name, config.oneHotColumnArrayOptions);
    // console.log({ encodedData, encoderMap, prefix });
    return encodedData.reduce((result, val) =&gt; {
      const columnNames = Object.keys(val).filter(prop =&gt; val[ prop ] === 1 &amp;&amp; (labels.indexOf(prop.replace(prefix, &apos;&apos;))!==-1 || labels.map(label=&gt;String(label)).indexOf(prop.replace(prefix, &apos;&apos;))!==-1));
      const columnName = columnNames[ 0 ]||&apos;&apos;; 
      // console.log({ columnName, columnNames, labels, val},Object.keys(val));
      const datum = {
        [ name ]: columnName.replace(prefix, &apos;&apos;),
      };
      result.push(datum);
      return result;
    }, []);
  }
  /**
   * returns a list of objects with only selected columns as properties
 * @example
const data = [{ Age: &apos;44&apos;, Salary: &apos;44&apos; , Height: &apos;34&apos; },
{ Age: &apos;27&apos;, Salary: &apos;44&apos; , Height: &apos;50&apos;  }]
const AgeDataSet = new MS.DataSet(data);
const cols = [ &apos;Age&apos;, &apos;Salary&apos; ];
const selectedCols = CSVDataSet.selectColumns(cols); // =&gt; [{ Age: &apos;44&apos;, Salary: &apos;44&apos; },
{ Age: &apos;27&apos;, Salary: &apos;27&apos; }]
   * 
   * @param {String[]} names - array of selected columns
   * @param {*} options 
   * @returns {Object[]} an array of objects with properties derived from names
   */
  static selectColumns(names, options = {}) {
    const config = Object.assign({}, options);
    const data = config.data || this.data;
    return data.reduce((result, val) =&gt; {
      const selectedData = {};
      names.forEach(name =&gt; {
        selectedData[ name ] = val[ name ];
      });
      result.push(selectedData);
      return result;
    }, []);
  }
  /**
   * returns a new array of a selected column from an array of objects, can filter, scale and replace values
   * @example 
   * //column Array returns column of data by name
// [ &apos;44&apos;,&apos;27&apos;,&apos;30&apos;,&apos;38&apos;,&apos;40&apos;,&apos;35&apos;,&apos;&apos;,&apos;48&apos;,&apos;50&apos;, &apos;37&apos; ]
const OringalAgeColumn = dataset.columnArray(&apos;Age&apos;); 
  * @param {string} name - csv column header, or JSON object property name 
  * @param options 
  * @param {function} [options.prefilter=(arr[val])=&gt;true] - prefilter values to return
  * @param {function} [options.filter=(arr[val])=&gt;true] - filter values to return
  * @param {function} [options.replace.test=undefined] - test function for replacing values (arr[val])
  * @param {(string|number|function)} [options.replace.value=undefined] - value to replace (arr[val]) if replace test is true, if a function (result,val,index,arr,name)=&gt;your custom value
  * @param {number} [options.parseIntBase=10] - radix value for parseInt
  * @param {boolean} [options.parseFloat=false] - convert values to floats 
  * @param {boolean} [options.parseInt=false] - converts values to ints 
  * @param {boolean} [options.scale=false] - standard or minmax feature scale values 
  * @returns {array}
  */
  static columnArray(name, options = {}) {
    const config = Object.assign({
      prefilter: () =&gt; true,
      filter: () =&gt; true,
      replace: {
        test: undefined,
        value: undefined,
      },
      parseInt: false,
      parseIntBase: 10,
      parseFloat: (options.scale) ? true : false,
      scale: false,
    }, options);
    const data = config.data || this.data;
    const modifiedColumn = data
      .filter(config.prefilter)
      .reduce((result, val, index, arr) =&gt; {
        let objVal = val[ name ];
        let returnVal = (typeof config.replace.test === &apos;function&apos;) ?
          config.replace.test(objVal) ?
            typeof config.replace.value === &apos;function&apos; ?
              config.replace.value(result, val, index, arr, name) :
              config.replace.value :
            objVal :
          objVal;
        if (config.filter(returnVal)) {
          if (config.parseInt) result.push(parseInt(returnVal, config.parseIntBase));
          else if (config.parseFloat) result.push(parseFloat(returnVal));
          else result.push(returnVal);
        }
        return result;
      }, []);
    if (typeof config.scale===&apos;function&apos;) {
      return modifiedColumn.map(config.scale);
    } else if (config.scale) {
      switch (config.scale) {
      case &apos;standard&apos;:
        return utils.StandardScaler(modifiedColumn);
      case &apos;log&apos;:
        return utils.LogScaler(modifiedColumn);
      case &apos;exp&apos;:
        return utils.ExpScaler(modifiedColumn);
      case &apos;normalize&apos;:
      default:
        return utils.MinMaxScaler(modifiedColumn);
      }
    } else {
      return modifiedColumn;
    }
  }
  
  /**
   * returns a matrix of values by combining column arrays into a matrix
   * @example const csvObj = new DataSet([{col1:1,col2:5},{col1:2,col2:6}]);
csvObj.columnMatrix([[&apos;col1&apos;,{parseInt:true}],[&apos;col2&apos;]]); // =&gt;
//[ 
//  [1,5], 
//  [2,6], 
//]
  * @param {Array} [vectors=[]] - array of arguments for columnArray to merge columns into a matrix
  * @param {Array} [data=[]] - array of data to convert to matrix
  * @returns {Array} a matrix of column values 
  */
  static columnMatrix(vectors = [], data = []) {
    const options = (data.length) ? { data, } : {};
    const columnVectors = (Array.isArray(vectors) &amp;&amp; Array.isArray(vectors[ 0 ]))
      ? vectors
      : vectors.map(vector =&gt; [vector, options,]);
    const vectorArrays = columnVectors
      .map(vec =&gt; DataSet.columnArray.call(this, ...vec));
        
    return utils.pivotArrays(vectorArrays);
  }
  /**
   * creates a new raw data instance for preprocessing data for machine learning
   * @example
   * const dataset = new ms.DataSet(csvData);
   * @param {Object[]} dataset
   * @returns {this} 
   */
  constructor(data = [], options) {
    this.config = Object.assign({
      debug: true,
    }, options);
    this.data = [...data,];
    this.labels = new Map();
    this.encoders = new Map();
    this.scalers = new Map();
    this.selectColumns = DataSet.selectColumns;
    this.columnArray = DataSet.columnArray;
    this.encodeObject = DataSet.encodeObject;
    this.oneHotEncoder = DataSet.oneHotEncoder;
    this.oneHotDecoder = DataSet.oneHotDecoder;
    this.columnMatrix = DataSet.columnMatrix;
    this.reverseColumnMatrix = DataSet.reverseColumnMatrix;
    this.reverseColumnVector = DataSet.reverseColumnVector;
    this.getTransforms = DataSet.getTransforms;
    return this;
  }
  /**
   * returns filtered rows of data 
   * @example const csvObj = new DataSet([{col1:1,col2:5},{col1:2,col2:6}]);
csvObj.filterColumn((row)=&gt;row.col1&gt;=2); // =&gt;
//[ 
//  [2,6], 
//]
  * @param {Function} [filter=()=&gt;true] - filter function
  * @returns {Array} filtered array of data 
  */
  filterColumn(filter = () =&gt; true) {
    return this.data.filter(filter);
  }
  /**
   * Returns a new array of scaled values which can be reverse (descaled). The scaling transformations are stored on the DataSet
   * @example
//dataset.columnArray(&apos;Age&apos;) =&gt; [ &apos;44&apos;,&apos;27&apos;,&apos;30&apos;,&apos;38&apos;,&apos;40&apos;,&apos;35&apos;,38.77777777777778,&apos;48&apos;,&apos;50&apos;,&apos;37&apos; ]
dataset.columnScale(&apos;Age&apos;,{strategy:&apos;log&apos;}) // =&gt; [ 3.784189633918261,
  3.295836866004329, 3.4011973816621555, 3.6375861597263857, 3.6888794541139363, 3.5553480614894135, 3.657847344866208, 3.8712010109078907, 3.912023005428146, 3.6109179126442243 ]
dataset.scalers.get(&apos;Age&apos;).scale(45) // =&gt; 3.8066624897703196
dataset.scalers.get(&apos;Age&apos;).descale(3.8066624897703196) // =&gt; 45
//this supports, log/exponent, minmax/normalization and standardscaling
   * @param {string} name - name - csv column header, or JSON object property name 
   * @param {string} [options.strategy=&quot;log&quot;] - strategy for scaling values 
   * @returns {number[]} returns an array of scaled values
   */
  columnScale(name, options = {}) {
    const input = (typeof options === &apos;string&apos;)
      ? { strategy: options, }
      : options;
    const config = Object.assign({
      strategy: &apos;log&apos;,
    }, input);
    let scaleData = config.data || this.columnArray(name, config.columnArrayOptions);
    let scaledData;
    let transforms;
      
    scaleData = scaleData.filter(datum =&gt; typeof datum !== &apos;undefined&apos;)
      .map((datum, i) =&gt; {
        if (typeof datum !== &apos;number&apos;) {
          if (this.config.debug) {
            console.error(TypeError(`Each value must be a number, error at index [${i}]`));
          }
          const num = Number(datum);
          if (isNaN(num)) throw TypeError(&apos;Only numerical values can be scaled i: &apos; + i + &apos; datum:&apos; + datum);
          return num;
        } else return datum;
      });
    switch (config.strategy) {
    case &apos;standard&apos;:
      transforms = utils.StandardScalerTransforms(scaleData);     
      this.scalers.set(name, {
        name,
        scale: transforms.scale,
        descale: transforms.descale,
        components: transforms.components,
      });
      scaledData = transforms.values;
      break;
    case &apos;normalize&apos;:
    case &apos;minmax&apos;:
      transforms = utils.MinMaxScalerTransforms(scaleData);     
      this.scalers.set(name, {
        name,
        scale: transforms.scale,
        descale: transforms.descale,
        components: transforms.components,
      });
      scaledData = transforms.values;
      break;
    case &apos;log&apos;:
    default:
      this.scalers.set(name, {
        name,
        scale: Math.log,
        descale: Math.exp,
        components: {
          average : utils.avg(scaleData),
          standard_dev : utils.sd(scaleData),
          maximum : utils.max(scaleData),
          minimum : utils.min(scaleData),
        },
      });
      scaledData = utils.LogScaler(scaleData);
      break;
    }
    return scaledData;
  }
  /**
   * Returns a new array of descaled values
   * @example
//dataset.columnArray(&apos;Age&apos;) =&gt; [ &apos;44&apos;,&apos;27&apos;,&apos;30&apos;,&apos;38&apos;,&apos;40&apos;,&apos;35&apos;,38.77777777777778,&apos;48&apos;,&apos;50&apos;,&apos;37&apos; ]
const scaledData = [ 3.784189633918261,
  3.295836866004329, 3.4011973816621555, 3.6375861597263857, 3.6888794541139363, 3.5553480614894135, 3.657847344866208, 3.8712010109078907, 3.912023005428146, 3.6109179126442243 ]
dataset.columnDescale(&apos;Age&apos;) // =&gt; [ &apos;44&apos;,&apos;27&apos;,&apos;30&apos;,&apos;38&apos;,&apos;40&apos;,&apos;35&apos;,38.77777777777778,&apos;48&apos;,&apos;50&apos;,&apos;37&apos; ]
   * @param {string} name - name - csv column header, or JSON object property name 
   * @param {string} [options.strategy=&quot;log&quot;] - strategy for scaling values 
   * @returns {number[]} returns an array of scaled values
   */
  columnDescale(name, options) {
    const config = Object.assign({ }, options);
    const scaledData = config.data || this.columnArray(name, config.columnArrayOptions);
    const descaleFunction = this.scalers.get(name).descale;
    return scaledData.map(descaleFunction);
  }
  /**
   * returns a new array and label encodes a selected column
   * @example
   * const oneHotCountryColumn = dataset.oneHotEncoder(&apos;Country&apos;); 

// [ &apos;N&apos;, &apos;Yes&apos;, &apos;No&apos;, &apos;f&apos;, &apos;Yes&apos;, &apos;Yes&apos;, &apos;false&apos;, &apos;Yes&apos;, &apos;No&apos;, &apos;Yes&apos; ] 
const originalPurchasedColumn = dataset.labelEncoder(&apos;Purchased&apos;);
// [ 0, 1, 0, 0, 1, 1, 1, 1, 0, 1 ]
const encodedBinaryPurchasedColumn = dataset.labelEncoder(&apos;Purchased&apos;,{ binary:true });
// [ 0, 1, 2, 3, 1, 1, 4, 1, 2, 1 ]
const encodedPurchasedColumn = dataset.labelEncoder(&apos;Purchased&apos;); 
  * @param {string} name - csv column header, or JSON object property name 
  * @param options
  * @param {boolean} [options.binary=false] - only replace with (0,1) with binary values 
  * @see {@link http://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.LabelEncoder.html} 
  * @returns {array}
  */
  labelEncoder(name, options) {
    const config = Object.assign({
      binary: false,
    }, options);
    const labelData = config.data || this.columnArray(name, config.columnArrayOptions);
    const labels = new Map(
      Array.from(new Set(labelData).values())
        .reduce((result, val, i, arr) =&gt; {
          result.push([val, i,]);
          result.push([i, val,]);
          return result;
        }, [])
    );
    this.labels.set(name, labels);
    const labeledData = (config.binary) ?
      labelData.map(label =&gt; {
        // console.log(label);
        if (!label) return 0;
        switch (label) {
        case false:
        case &apos;N&apos;:
        case &apos;n&apos;:
        case &apos;NO&apos;:
        case &apos;No&apos;:
        case &apos;no&apos;:
        case &apos;False&apos;:
        case &apos;F&apos;:
        case &apos;f&apos;:
          return 0;
        default:
          return 1;
        }
      }) :
      labelData.map(label =&gt; labels.get(label));
    return labeledData;
  }
  /**
     * returns a new array and decodes an encoded column back to the original array values
     * @param {string} name - csv column header, or JSON object property name 
     * @param options
     * @returns {array}
     */
  labelDecode(name, options) {
    const config = Object.assign({}, options);
    const labelData = config.data || this.columnArray(name, config.columnArrayOptions);
    return labelData.map(val =&gt; this.labels.get(name).get(val));
  }
  /**
   * Return one hot encoded data
   * @example
const csvData = [{
    &apos;Country&apos;: &apos;Brazil&apos;,
    &apos;Age&apos;: &apos;44&apos;,
    &apos;Salary&apos;: &apos;72000&apos;,
    &apos;Purchased&apos;: &apos;N&apos;,
  },
  {
    &apos;Country&apos;: &apos;Mexico&apos;,
    &apos;Age&apos;: &apos;27&apos;,
    &apos;Salary&apos;: &apos;48000&apos;,
    &apos;Purchased&apos;: &apos;Yes&apos;,
  },
  ...
];
const EncodedCSVDataSet = new ms.preprocessing.DataSet(csvData);
EncodedCSVDataSet.fitColumns({
  columns: [
    {
      name: &apos;Country&apos;,
      options: { strategy: &apos;onehot&apos;, },
    },
  ],
});

EncodedCSVDataSet.oneHotColumnArray(&apos;Country);// =&gt;
// [ { Country_Brazil: 1, Country_Mexico: 0, Country_Ghana: 0 },
//   { Country_Brazil: 0, Country_Mexico: 1, Country_Ghana: 0 },
//   { Country_Brazil: 0, Country_Mexico: 0, Country_Ghana: 1 },
//   ...]
   * @param {string} name - column name 
   * @param options 
   * @returns {Array&lt;Object&gt;} returns an array of objects from an one hot encoded column
   */
  oneHotColumnArray(name, options) {
    const config = Object.assign({
      // handle_unknown: &apos;error&apos;
    }, options);
    const labels = config.labels || this.encoders.get(name).labels;
    const prefix = config.prefix || this.encoders.get(name).prefix;
    return this.selectColumns(labels.map(label =&gt; `${prefix}${label}`));
  }
  /**
 * it returns a new column that reduces a column into a new column object, this is used in data prep to create new calculated columns for aggregrate statistics
 * @example 
const reducer = (result, value, index, arr) =&gt; {
result.push(value * 2);
return result;
};
CSVDataSet.columnReducer(&apos;DoubleAge&apos;, {
columnName: &apos;Age&apos;,
reducer,
}); //=&gt; { DoubleAge: [ 88, 54, 60, 76, 80, 70, 0, 96, 100, 74 ] }
  * @param {String} name - name of new Column 
  * @param {Object} options 
  * @param {String} options.columnName - name property for columnArray selection 
  * @param {Object} options.columnOptions - options property for columnArray  
  * @param {Function} options.reducer - reducer function to reduce into new array, it should push values into the resulting array  
  * @returns {Object} a new object that has reduced array as the value
  */
  columnReducer(name, options) {
    const newColumn = {
      [ name ]: this.columnArray(options.columnName, options.columnOptions).reduce(options.reducer, []),
    };
    return newColumn;
  }
  /**
   * it returns a new column that is merged onto the data set
   * @example 
CSVDataSet.columnMerge(&apos;DoubleAge&apos;, [ 88, 54, 60, 76, 80, 70, 0, 96, 100, 74 ]); //=&gt; { DoubleAge: [ 88, 54, 60, 76, 80, 70, 0, 96, 100, 74 ] }
    * @param {String} name - name of new Column 
    * @param {Array} data - new dataset data  
    * @returns {Object} 
    */
  columnMerge(name, data=[]) {
    if (this.data.length !== data.length) throw new RangeError(`Merged data column must have the same length(${data.length}) as the DataSet&apos;s length (${this.data.length})`);
    return {
      [name]: data,
    };
  }
  /**
   * Inverses transform on an object
   * @example
DataSet.data; //[{
//   Age: 0.6387122698222066,
//   Salary: 72000,
//   Purchased: 0,
//   Country_Brazil: 1,
//   Country_Mexico: 0,
//   Country_Ghana: 0,
// }, ...] 
DataSet.inverseTransformObject(DataSet.data[0]); // =&gt; {
//  Country: &apos;Brazil&apos;, 
//  Age: 44, 
//  Salary: 72000, 
//  Purchased: &apos;N&apos;, 
// };
   * @param data 
   * @param options 
   * @returns {Object} returns object with inverse transformed data
   */
  inverseTransformObject(data, options) {
    const config = Object.assign({
      removeValues: false,
    }, options);
    const removedColumns = [];
    let transformedObject = Object.assign({}, data);
    const columnNames = Object.keys(this.data[ 0 ]);
    const scaledData = columnNames.reduce((scaleObject, columnName) =&gt; {
      if (this.scalers.has(columnName)){
        scaleObject[ columnName ] = this.scalers.get(columnName).descale(data[ columnName ]);
      }
      return scaleObject;
    }, {});
    const labeledData = columnNames.reduce((labelObject, columnName) =&gt; {
      if (this.labels.has(columnName)){
        labelObject[ columnName ] = this.labels.get(columnName).get(data[ columnName ]);
      }
      return labelObject;
    }, {});
    const encodedData = columnNames.reduce((encodedObject, columnName) =&gt; {
      if (this.encoders.has(columnName)) {
        const encoded = this.oneHotDecoder(columnName, {
          data: [data,],
        });
        // console.log({encoded})
        encodedObject = Object.assign({}, encodedObject, encoded[ 0 ]);
        if (config.removeValues) {
          removedColumns.push(...this.encoders.get(columnName).labels.map(label=&gt;`${this.encoders.get(columnName).prefix}${label}`));
        }
      }
      return encodedObject;
    }, {});
    transformedObject = Object.assign(transformedObject, scaledData, labeledData, encodedData);
    if (config.removeValues &amp;&amp; removedColumns.length) {
      transformedObject = Object.keys(transformedObject).reduce((removedObject, propertyName) =&gt; {
        if (removedColumns.indexOf(propertyName) === -1) {
          removedObject[ propertyName ] = transformedObject[ propertyName ];
        }
        return removedObject;
      }, {});
    }
    return transformedObject;
  }
  /**
   * transforms an object and replaces values that have been scaled or encoded
   * @example
DataSet.transformObject({
  &apos;Country&apos;: &apos;Brazil&apos;,
  &apos;Age&apos;: &apos;44&apos;,
  &apos;Salary&apos;: &apos;72000&apos;,
  &apos;Purchased&apos;: &apos;N&apos;,
}); // =&gt;
// { 
//  Country: &apos;Brazil&apos;,
//  Age: 3.784189633918261,
//  Salary: &apos;72000&apos;,
//  Purchased: &apos;N&apos;,
//  Country_Brazil: 1,
//  Country_Mexico: 0,
//  Country_Ghana: 0
// }
   * @param data 
   * @param options 
   * @returns {Object} 
   */
  transformObject(data, options) {
    const config = Object.assign({
      removeValues: false,
      checkColumnLength: true,
    }, options);
    const removedColumns = [];
    // if (Array.isArray(data)) return data.map(datum =&gt; this.transformObject);
    const encodedColumns = [].concat(...Array.from(this.encoders.keys())
      .map(encodedColumn =&gt; this.encoders.get(encodedColumn).labels
        .map(label=&gt;`${this.encoders.get(encodedColumn).prefix}${label}`)
      )
    );
    const currentColumns = Object.keys(this.data[ 0 ]);
    const objectColumns = Object.keys(data).concat(encodedColumns);
    // console.log({ encodedColumns,currentColumns,objectColumns });
    const differentKeys = objectColumns.reduce((diffKeys, val) =&gt; {
      if (currentColumns.indexOf(val) === -1 &amp;&amp; encodedColumns.indexOf(val) === -1) diffKeys.push(val);
      return diffKeys;
    }, []);
    let transformedObject = Object.assign({}, data);
    if (config.checkColumnLength &amp;&amp; currentColumns.length !== objectColumns.length &amp;&amp; currentColumns.length+encodedColumns.length !== objectColumns.length ) {
      throw new RangeError(`Object must have the same number of keys (${objectColumns.length}) as data in your dataset(${currentColumns.length})`);
    } else if (config.checkColumnLength &amp;&amp; differentKeys.length) {
      throw new ReferenceError(`Object must have identical keys as data in your DataSet. Invalid keys: ${differentKeys.join(&apos;,&apos;)}`);
    } else {
      const scaledData = objectColumns.reduce((scaleObject, columnName) =&gt; {
        if (this.scalers.has(columnName)){
          scaleObject[ columnName ] = this.scalers.get(columnName).scale(data[ columnName ]);
        }
        return scaleObject;
      }, {});
      const labeledData = objectColumns.reduce((labelObject, columnName) =&gt; {
        if (this.labels.has(columnName)){
          labelObject[ columnName ] = this.labels.get(columnName).get(data[ columnName ]);
        }
        return labelObject;
      }, {});
      const encodedData = objectColumns.reduce((encodedObject, columnName) =&gt; {
        if (this.encoders.has(columnName)) {
          encodedObject = Object.assign({}, encodedObject, this.encodeObject(data, this.encoders.get(columnName)));
          if (config.removeValues) {
            removedColumns.push(columnName);
          }
        }
        return encodedObject;
      }, {});
      transformedObject = Object.assign(transformedObject, scaledData, labeledData, encodedData);
      if (config.removeValues &amp;&amp; removedColumns.length) {
        transformedObject = Object.keys(transformedObject).reduce((removedObject, propertyName) =&gt; {
          if (removedColumns.indexOf(propertyName) === -1) removedObject[ propertyName ] = transformedObject[ propertyName ];
          return removedObject;
        }, {});
      }
    }
    return transformedObject;
  } 
  /**
   * returns a new array of a selected column from an array of objects and replaces empty values, encodes values and scales values
   * @example
   * //column Replace returns new Array with replaced missing data
//[ &apos;44&apos;,&apos;27&apos;,&apos;30&apos;,&apos;38&apos;,&apos;40&apos;,&apos;35&apos;,38.77777777777778,&apos;48&apos;,&apos;50&apos;,&apos;37&apos; ]
const ReplacedAgeMeanColumn = dataset.columnReplace(&apos;Age&apos;,{strategy:&apos;mean&apos;});
  * @param {string} name - csv column header, or JSON object property name 
  * @param options 
  * @param {boolean} [options.empty=true] - replace empty values 
  * @param {boolean} [options.strategy=&quot;mean&quot;] - strategy for replacing value, any array stat method from ml.js (mean, standardDeviation, median) or (label,labelEncoder,onehot,oneHotEncoder)
  * @returns {array|Object[]}
  */
  columnReplace(name, options = {}) {
    const config = Object.assign({
      strategy: &apos;mean&apos;,
      empty: true,
      arrayOptions: {
        parseFloat: true,
        filter: val =&gt; val,
      },
      labelOptions: {},
    }, options);
    let replaceVal;
    let replace = {
      test: val =&gt; !val,
      value: replaceVal,
    };
    switch (config.strategy) {
    case &apos;scale&apos;:
      replaceVal = this.columnScale(name, config.scaleOptions);
      replace = {
        test: val =&gt; true,
        value: (result, val, index, arr) =&gt; replaceVal[index],
      };
      break;
    case &apos;descale&apos;:
      replaceVal = this.columnDescale(name, config.descaleOptions);
      replace = {
        test: val =&gt; true,
        value: (result, val, index, arr) =&gt; replaceVal[index],
      };
      break;
    case &apos;label&apos;:
    case &apos;labelEncoder&apos;:
      replaceVal = this.labelEncoder(name, config.labelOptions);
      replace = {
        test: val =&gt; true,
        value: (result, val, index, arr) =&gt; replaceVal[index],
      };
      break;
    case &apos;labeldecode&apos;:
    case &apos;labelDecode&apos;:
    case &apos;labelDecoder&apos;:
      replaceVal = this.labelDecode(name, config.labelOptions);
      replace = {
        test: val =&gt; true,
        value: (result, val, index, arr) =&gt; replaceVal[index],
      };
      break;
    case &apos;onehot&apos;:
    case &apos;oneHot&apos;:
    case &apos;oneHotEncode&apos;:
    case &apos;oneHotEncoder&apos;:
      replaceVal = this.oneHotEncoder(name, config.oneHotOptions);
      replace = {
        test: val =&gt; true,
        value: (result, val, index, arr) =&gt; replaceVal[index],
      };
      return replaceVal;
      // break;
    case &apos;reducer&apos;:
    case &apos;reduce&apos;:
      replaceVal = this.columnReducer(name, config.reducerOptions); 
      return replaceVal;  
    case &apos;merge&apos;:
      replaceVal = this.columnMerge(name, config.mergeData); 
      return replaceVal; 
    case &apos;parseNumber&apos;:
      replaceVal = this.columnArray(name).map(num =&gt; Number(num)); 
      return replaceVal; 
    default:
      replaceVal = ml.ArrayStat[config.strategy](this.columnArray(name, config.arrayOptions));
      replace.value = replaceVal;
      break;
    }
    return this.columnArray(name,
      Object.assign({}, {
        replace,
        scale: options.scale,
      }, options.columnOptions));
  }
  /**
     * mutates data property of DataSet by replacing multiple columns in a single command
     * @example
     * //fit Columns, mutates dataset
dataset.fitColumns({
  columns:[{name:&apos;Age&apos;,options:{ strategy:&apos;mean&apos;} }]
});
// dataset
// class DataSet
//   data:[
//     {
//       &apos;Country&apos;: &apos;Brazil&apos;,
//       &apos;Age&apos;: &apos;38.77777777777778&apos;,
//       &apos;Salary&apos;: &apos;72000&apos;,
//       &apos;Purchased&apos;: &apos;N&apos;,
//     }
//     ...
//   ]
  * @param {Boolean} options.returnData - return updated DataSet data property 
  * @param {Object[]} options.columns - {name:&apos;columnName&apos;,options:{strategy:&apos;mean&apos;,labelOoptions:{}},}
  * @returns {Object[]}
  */
  fitColumns(options = {}) {
    const config = Object.assign({
      returnData:true,
      columns: [],
    }, options);
    if ( !options.columns || Array.isArray(options.columns) ===false) {
      config.columns = (options.columns)
        ? DataSet.getTransforms(options.columns)
        : DataSet.getTransforms(options);
    }

    const fittedColumns = config.columns
      .reduce((result, val, index, arr) =&gt; {
        let replacedColumn = this.columnReplace(val.name, val.options);
        if (Array.isArray(replacedColumn)) {
          replacedColumn = replacedColumn.map(columnVal =&gt; ({
            [val.name]: columnVal,
          }));
          result[val.name] = replacedColumn;
        } else {
          Object.keys(replacedColumn).forEach(repColName =&gt; {
            result[repColName] = replacedColumn[repColName].map(columnVal =&gt; ({
              [repColName]: columnVal,
            }));
          });
        }
        return result;
      }, {});
    if (Object.keys(fittedColumns) &amp;&amp; Object.keys(fittedColumns).length) {
      const columnNames = Object.keys(fittedColumns);
      const fittedData = fittedColumns[columnNames[0]]
        .reduce((result, val, index, arr) =&gt; {
          const returnObj = {};
          columnNames.forEach(colName =&gt; {
            returnObj[colName] = fittedColumns[colName][index][colName];
          });
          result.push(returnObj);
          return result;
        }, []);
      this.data = this.data.map((val, index) =&gt; Object.assign({}, val, fittedData[index]));
    }
    return config.returnData ? this.data : this;
  }
  /**
   * Mutate dataset data by inversing all transforms
   * @example
DataSet.data;
// [{ 
//  Country: &apos;Brazil&apos;,
//  Age: 3.784189633918261,
//  Salary: &apos;72000&apos;,
//  Purchased: &apos;N&apos;,
//  Country_Brazil: 1,
//  Country_Mexico: 0,
//  Country_Ghana: 0
// },
// ...
// ]
DataSet.fitInverseTransforms(); // =&gt;
// [{
//   &apos;Country&apos;: &apos;Brazil&apos;,
//   &apos;Age&apos;: &apos;44&apos;,
//   &apos;Salary&apos;: &apos;72000&apos;,
//   &apos;Purchased&apos;: &apos;N&apos;,
// },
// ...
// ]
   * @param options 
   */
  fitInverseTransforms(options = {}) {
    const config = Object.assign({
      returnData: true,
    }, options);
    this.data = this.data.map(val =&gt; {
      return (options.removeValues)
        ? this.inverseTransformObject(val, options)
        : Object.assign({}, val, this.inverseTransformObject(val, options));
    });
    return config.returnData ? this.data : this;
  }
  /**
   * Mutate dataset data with all transforms
   * @param options
   * @example
DataSet.data;
// [{
//   &apos;Country&apos;: &apos;Brazil&apos;,
//   &apos;Age&apos;: &apos;44&apos;,
//   &apos;Salary&apos;: &apos;72000&apos;,
//   &apos;Purchased&apos;: &apos;N&apos;,
// },
// ...
// ]
DataSet.fitTransforms(); // =&gt;
// [{ 
//  Country: &apos;Brazil&apos;,
//  Age: 3.784189633918261,
//  Salary: &apos;72000&apos;,
//  Purchased: &apos;N&apos;,
//  Country_Brazil: 1,
//  Country_Mexico: 0,
//  Country_Ghana: 0
// },
// ...
// ] 
   */
  fitTransforms(options = {}) {
    const config = Object.assign({
      returnData: true,
    }, options);
    this.data = this.data.map(val =&gt; {
      return (options.removeValues)
        ? this.transformObject(val, options)
        : Object.assign({}, val, this.transformObject(val, options));
    });
    return config.returnData ? this.data : this;
  }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>


</body></html>